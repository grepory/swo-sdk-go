/*
SolarWinds Observability REST API

[Rest API Documentation](https://documentation.solarwinds.com/en/success_center/observability/content/api/api-swagger.htm)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package swov1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MetricsAPIService MetricsAPI service
type MetricsAPIService service

type ApiGetMetricRequest struct {
	ctx context.Context
	ApiService *MetricsAPIService
	name string
}

func (r ApiGetMetricRequest) Execute() (*GetMetricResponse, *http.Response, error) {
	return r.ApiService.GetMetricExecute(r)
}

/*
GetMetric Get metric info

Get info about a metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name metric name
 @return ApiGetMetricRequest
*/
func (a *MetricsAPIService) GetMetric(ctx context.Context, name string) ApiGetMetricRequest {
	return ApiGetMetricRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return GetMetricResponse
func (a *MetricsAPIService) GetMetricExecute(r ApiGetMetricRequest) (*GetMetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMetricAttributeNamesRequest struct {
	ctx context.Context
	ApiService *MetricsAPIService
	name string
	startTime *string
	endTime *string
	pageSize *int32
	skipToken *string
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricAttributeNamesRequest) StartTime(startTime string) ApiListMetricAttributeNamesRequest {
	r.startTime = &startTime
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricAttributeNamesRequest) EndTime(endTime string) ApiListMetricAttributeNamesRequest {
	r.endTime = &endTime
	return r
}

// Number of attribute names in a response page
func (r ApiListMetricAttributeNamesRequest) PageSize(pageSize int32) ApiListMetricAttributeNamesRequest {
	r.pageSize = &pageSize
	return r
}

// For opaque pagination, with default value : empty string
func (r ApiListMetricAttributeNamesRequest) SkipToken(skipToken string) ApiListMetricAttributeNamesRequest {
	r.skipToken = &skipToken
	return r
}

func (r ApiListMetricAttributeNamesRequest) Execute() (*ListMetricAttributeNamesResponse, *http.Response, error) {
	return r.ApiService.ListMetricAttributeNamesExecute(r)
}

/*
ListMetricAttributeNames List metric attribute names

List all attribute names defined for the given metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name metric name
 @return ApiListMetricAttributeNamesRequest
*/
func (a *MetricsAPIService) ListMetricAttributeNames(ctx context.Context, name string) ApiListMetricAttributeNamesRequest {
	return ApiListMetricAttributeNamesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ListMetricAttributeNamesResponse
func (a *MetricsAPIService) ListMetricAttributeNamesExecute(r ApiListMetricAttributeNamesRequest) (*ListMetricAttributeNamesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMetricAttributeNamesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.ListMetricAttributeNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/{name}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.skipToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipToken", r.skipToken, "")
	} else {
		var defaultValue string = ""
		r.skipToken = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMetricAttributeValuesRequest struct {
	ctx context.Context
	ApiService *MetricsAPIService
	name string
	attributeName string
	startTime *string
	endTime *string
	pageSize *int32
	skipToken *string
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricAttributeValuesRequest) StartTime(startTime string) ApiListMetricAttributeValuesRequest {
	r.startTime = &startTime
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricAttributeValuesRequest) EndTime(endTime string) ApiListMetricAttributeValuesRequest {
	r.endTime = &endTime
	return r
}

// Number of attribute values in a response page
func (r ApiListMetricAttributeValuesRequest) PageSize(pageSize int32) ApiListMetricAttributeValuesRequest {
	r.pageSize = &pageSize
	return r
}

// For opaque pagination, with default value : empty string
func (r ApiListMetricAttributeValuesRequest) SkipToken(skipToken string) ApiListMetricAttributeValuesRequest {
	r.skipToken = &skipToken
	return r
}

func (r ApiListMetricAttributeValuesRequest) Execute() (*ListMetricAttributeValuesResponse, *http.Response, error) {
	return r.ApiService.ListMetricAttributeValuesExecute(r)
}

/*
ListMetricAttributeValues List metric attribute values

List values of a metric's attribute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name metric name
 @param attributeName attribute name
 @return ApiListMetricAttributeValuesRequest
*/
func (a *MetricsAPIService) ListMetricAttributeValues(ctx context.Context, name string, attributeName string) ApiListMetricAttributeValuesRequest {
	return ApiListMetricAttributeValuesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		attributeName: attributeName,
	}
}

// Execute executes the request
//  @return ListMetricAttributeValuesResponse
func (a *MetricsAPIService) ListMetricAttributeValuesExecute(r ApiListMetricAttributeValuesRequest) (*ListMetricAttributeValuesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMetricAttributeValuesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.ListMetricAttributeValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/{name}/attributes/{attributeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attributeName"+"}", url.PathEscape(parameterValueToString(r.attributeName, "attributeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.skipToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipToken", r.skipToken, "")
	} else {
		var defaultValue string = ""
		r.skipToken = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMetricMeasurementsRequest struct {
	ctx context.Context
	ApiService *MetricsAPIService
	name string
	filter *string
	groupBy *string
	aggregateBy *string
	bucketSizeInSeconds *int32
	preGroupBy *string
	preGroupByMethod *string
	startTime *string
	endTime *string
	pageSize *int32
	skipToken *string
}

// Query to filter the measurement values. e.g  id:[id1,id2] category:moderate
func (r ApiListMetricMeasurementsRequest) Filter(filter string) ApiListMetricMeasurementsRequest {
	r.filter = &filter
	return r
}

// CSV string of attribute names to group measurements by. e.g id,category
func (r ApiListMetricMeasurementsRequest) GroupBy(groupBy string) ApiListMetricMeasurementsRequest {
	r.groupBy = &groupBy
	return r
}

// One of COUNT, MIN, MAX, AVG, SUM, or LAST
func (r ApiListMetricMeasurementsRequest) AggregateBy(aggregateBy string) ApiListMetricMeasurementsRequest {
	r.aggregateBy = &aggregateBy
	return r
}

// Resolution size of an aggregation bucket in seconds
func (r ApiListMetricMeasurementsRequest) BucketSizeInSeconds(bucketSizeInSeconds int32) ApiListMetricMeasurementsRequest {
	r.bucketSizeInSeconds = &bucketSizeInSeconds
	return r
}

// Secondary grouping to allow aggregating data points inside individual buckets.    Has to be set together with &#x60;preGroupByMethod&#x60;
func (r ApiListMetricMeasurementsRequest) PreGroupBy(preGroupBy string) ApiListMetricMeasurementsRequest {
	r.preGroupBy = &preGroupBy
	return r
}

// Secondary aggregation to allow aggregating data points inside individual buckets.    Has to be set together with &#x60;preGroupBy&#x60;
func (r ApiListMetricMeasurementsRequest) PreGroupByMethod(preGroupByMethod string) ApiListMetricMeasurementsRequest {
	r.preGroupByMethod = &preGroupByMethod
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricMeasurementsRequest) StartTime(startTime string) ApiListMetricMeasurementsRequest {
	r.startTime = &startTime
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricMeasurementsRequest) EndTime(endTime string) ApiListMetricMeasurementsRequest {
	r.endTime = &endTime
	return r
}

// Number of groupings in a response page
func (r ApiListMetricMeasurementsRequest) PageSize(pageSize int32) ApiListMetricMeasurementsRequest {
	r.pageSize = &pageSize
	return r
}

// For opaque pagination, with default value : empty string
func (r ApiListMetricMeasurementsRequest) SkipToken(skipToken string) ApiListMetricMeasurementsRequest {
	r.skipToken = &skipToken
	return r
}

func (r ApiListMetricMeasurementsRequest) Execute() (*ListMetricMeasurementsResponse, *http.Response, error) {
	return r.ApiService.ListMetricMeasurementsExecute(r)
}

/*
ListMetricMeasurements List metric's measurement values for a metric

List metric measurement values, grouped by attributes, filtered by the filter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name metric name
 @return ApiListMetricMeasurementsRequest
*/
func (a *MetricsAPIService) ListMetricMeasurements(ctx context.Context, name string) ApiListMetricMeasurementsRequest {
	return ApiListMetricMeasurementsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ListMetricMeasurementsResponse
func (a *MetricsAPIService) ListMetricMeasurementsExecute(r ApiListMetricMeasurementsRequest) (*ListMetricMeasurementsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMetricMeasurementsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.ListMetricMeasurements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/{name}/measurements"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", r.groupBy, "")
	}
	if r.aggregateBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregateBy", r.aggregateBy, "")
	} else {
		var defaultValue string = "AVG"
		r.aggregateBy = &defaultValue
	}
	if r.bucketSizeInSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucketSizeInSeconds", r.bucketSizeInSeconds, "")
	}
	if r.preGroupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preGroupBy", r.preGroupBy, "")
	}
	if r.preGroupByMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preGroupByMethod", r.preGroupByMethod, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.skipToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipToken", r.skipToken, "")
	} else {
		var defaultValue string = ""
		r.skipToken = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMetricsRequest struct {
	ctx context.Context
	ApiService *MetricsAPIService
	name *string
	startTime *string
	endTime *string
	pageSize *int32
	skipToken *string
}

// metric name
func (r ApiListMetricsRequest) Name(name string) ApiListMetricsRequest {
	r.name = &name
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricsRequest) StartTime(startTime string) ApiListMetricsRequest {
	r.startTime = &startTime
	return r
}

// yyyy-MM-ddTHH:mm:ssZ
func (r ApiListMetricsRequest) EndTime(endTime string) ApiListMetricsRequest {
	r.endTime = &endTime
	return r
}

// Number of metrics in a response page
func (r ApiListMetricsRequest) PageSize(pageSize int32) ApiListMetricsRequest {
	r.pageSize = &pageSize
	return r
}

// For opaque pagination, with default value : empty string
func (r ApiListMetricsRequest) SkipToken(skipToken string) ApiListMetricsRequest {
	r.skipToken = &skipToken
	return r
}

func (r ApiListMetricsRequest) Execute() (*ListMetricsResponse, *http.Response, error) {
	return r.ApiService.ListMetricsExecute(r)
}

/*
ListMetrics List metrics

List metrics seen within a time period

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMetricsRequest
*/
func (a *MetricsAPIService) ListMetrics(ctx context.Context) ApiListMetricsRequest {
	return ApiListMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListMetricsResponse
func (a *MetricsAPIService) ListMetricsExecute(r ApiListMetricsRequest) (*ListMetricsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMetricsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.ListMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.skipToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipToken", r.skipToken, "")
	} else {
		var defaultValue string = ""
		r.skipToken = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
